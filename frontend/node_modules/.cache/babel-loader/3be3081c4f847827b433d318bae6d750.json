{"ast":null,"code":"import _defineProperty from \"/Users/johnleavell/Desktop/cautious-fiesta/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"/Users/johnleavell/Desktop/cautious-fiesta/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/johnleavell/Desktop/cautious-fiesta/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/johnleavell/Desktop/cautious-fiesta/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/johnleavell/Desktop/cautious-fiesta/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/johnleavell/Desktop/cautious-fiesta/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"/Users/johnleavell/Desktop/cautious-fiesta/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nvar _jsxFileName = \"/Users/jquense/src/uncontrollable/src/uncontrollable.js\";\nimport React from 'react';\nimport { polyfill } from 'react-lifecycles-compat';\nimport invariant from 'invariant';\nimport * as Utils from './utils';\nexport default function uncontrollable(Component, controlledValues, methods) {\n  var _this4 = this;\n\n  if (methods === void 0) {\n    methods = [];\n  }\n\n  var displayName = Component.displayName || Component.name || 'Component';\n  var canAcceptRef = Utils.canAcceptRef(Component);\n  var controlledProps = Object.keys(controlledValues);\n  var PROPS_TO_OMIT = controlledProps.map(Utils.defaultKey);\n  !(canAcceptRef || !methods.length) ? process.env.NODE_ENV !== \"production\" ? invariant(false, '[uncontrollable] stateless function components cannot pass through methods ' + 'because they have no associated instances. Check component: ' + displayName + ', ' + 'attempting to pass through methods: ' + methods.join(', ')) : invariant(false) : void 0;\n\n  var UncontrolledComponent = /*#__PURE__*/function (_React$Component) {\n    _inherits(UncontrolledComponent, _React$Component);\n\n    function UncontrolledComponent() {\n      var _this2;\n\n      _classCallCheck(this, UncontrolledComponent);\n\n      var _this;\n\n      _this2 = _possibleConstructorReturn(this, _getPrototypeOf(UncontrolledComponent).apply(this, arguments));\n      _this = _assertThisInitialized(_assertThisInitialized(_this2));\n      _this2.handlers = Object.create(null);\n      controlledProps.forEach(function (propName) {\n        var handlerName = controlledValues[propName];\n\n        var handleChange = function handleChange(value) {\n          if (_this.props[handlerName]) {\n            var _this$props2;\n\n            _this._notifying = true;\n\n            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n              args[_key - 1] = arguments[_key];\n            }\n\n            (_this$props2 = _this.props)[handlerName].apply(_this$props2, [value].concat(args));\n\n            _this._notifying = false;\n          }\n\n          if (!_this.unmounted) _this.setState(function (_ref) {\n            var values = _ref.values;\n            return {\n              values: _extends(Object.create(null), values, _defineProperty({}, propName, value))\n            };\n          });\n        };\n\n        _this2.handlers[handlerName] = handleChange;\n      });\n      if (methods.length) _this2.attachRef = function (ref) {\n        _this2.inner = ref;\n      };\n      var values = Object.create(null);\n      controlledProps.forEach(function (key) {\n        values[key] = _this2.props[Utils.defaultKey(key)];\n      });\n      _this2.state = {\n        values: values,\n        prevProps: {}\n      };\n      return _this2;\n    }\n\n    _createClass(UncontrolledComponent, [{\n      key: \"shouldComponentUpdate\",\n      value: function shouldComponentUpdate() {\n        //let setState trigger the update\n        return !this._notifying;\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        this.unmounted = true;\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this3 = this;\n\n        var _this$props = this.props,\n            innerRef = _this$props.innerRef,\n            props = _objectWithoutPropertiesLoose(_this$props, [\"innerRef\"]);\n\n        PROPS_TO_OMIT.forEach(function (prop) {\n          delete props[prop];\n        });\n        var newProps = {};\n        controlledProps.forEach(function (propName) {\n          var propValue = _this3.props[propName];\n          newProps[propName] = propValue !== undefined ? propValue : _this3.state.values[propName];\n        });\n        return React.createElement(Component, _extends({}, props, newProps, this.handlers, {\n          ref: innerRef || this.attachRef\n        }));\n      }\n    }], [{\n      key: \"getDerivedStateFromProps\",\n      value: function getDerivedStateFromProps(props, _ref2) {\n        var values = _ref2.values,\n            prevProps = _ref2.prevProps;\n        var nextState = {\n          values: _extends(Object.create(null), values),\n          prevProps: {}\n        };\n        controlledProps.forEach(function (key) {\n          /**\n           * If a prop switches from controlled to Uncontrolled\n           * reset its value to the defaultValue\n           */\n          nextState.prevProps[key] = props[key];\n\n          if (!Utils.isProp(props, key) && Utils.isProp(prevProps, key)) {\n            nextState.values[key] = props[Utils.defaultKey(key)];\n          }\n        });\n        return nextState;\n      }\n    }]);\n\n    return UncontrolledComponent;\n  }(React.Component);\n\n  polyfill(UncontrolledComponent);\n  UncontrolledComponent.displayName = \"Uncontrolled(\".concat(displayName, \")\");\n  UncontrolledComponent.propTypes = _extends({\n    innerRef: function innerRef() {}\n  }, Utils.uncontrolledPropTypes(controlledValues, displayName));\n  methods.forEach(function (method) {\n    UncontrolledComponent.prototype[method] = function $proxiedMethod() {\n      var _this$inner;\n\n      return (_this$inner = this.inner)[method].apply(_this$inner, arguments);\n    };\n  });\n  var WrappedComponent = UncontrolledComponent;\n\n  if (React.forwardRef) {\n    WrappedComponent = React.forwardRef(function (props, ref) {\n      return React.createElement(UncontrolledComponent, _extends({}, props, {\n        innerRef: ref,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 128\n        },\n        __self: _this4\n      }));\n    });\n    WrappedComponent.propTypes = UncontrolledComponent.propTypes;\n  }\n\n  WrappedComponent.ControlledComponent = Component;\n  /**\n   * useful when wrapping a Component and you want to control\n   * everything\n   */\n\n  WrappedComponent.deferControlTo = function (newComponent, additions, nextMethods) {\n    if (additions === void 0) {\n      additions = {};\n    }\n\n    return uncontrollable(newComponent, _extends({}, controlledValues, additions), nextMethods);\n  };\n\n  return WrappedComponent;\n}","map":null,"metadata":{},"sourceType":"module"}